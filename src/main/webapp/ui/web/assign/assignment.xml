<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ev="http://www.w3.org/2001/xml-events" xmlns:w2="http://www.inswave.com/websquare" xmlns:xf="http://www.w3.org/2002/xforms">
    <head>
        <w2:type>COMPONENT</w2:type>
        <w2:buildDate/>
        <w2:MSA/>
        <xf:model>
            <w2:dataCollection baseNode="map">
                <!-- assignRuleVo를 위한 별도 dataMap 추가 -->
                <w2:dataMap baseNode="map" id="dmp_assignRuleVo" style="">
                    <w2:keyInfo>
                        <w2:key dataType="text" id="rule_id" name="규칙ID"></w2:key>
                        <w2:key dataType="text" id="keyword" name="키워드"></w2:key>
                        <w2:key dataType="text" id="dept" name="부서명"></w2:key>
                    </w2:keyInfo>
                </w2:dataMap>
                
                <!-- 기존 modalData는 그대로 유지 -->
                <w2:dataMap baseNode="map" id="dma_modalData">
                    <w2:keyInfo>
                        <w2:key dataType="text" id="keyword" name="키워드"/>
                        <w2:key dataType="text" id="department" name="부서"/>
                        <!-- 페이징을 위한 키 추가 -->
                        <w2:key dataType="text" id="pageIndex" name="페이지번호" defaultValue="1"/>
                        <w2:key dataType="text" id="pageSize" name="페이지사이즈" defaultValue="100"/>
                    </w2:keyInfo>
                </w2:dataMap>
                
                <!-- 부서 목록을 저장할 dataList -->
                <w2:dataList baseNode="list" id="dlt_departmentList" saveRemovedData="true">
                    <w2:columnInfo>
                        <w2:column dataType="text" id="dept_id" name="부서ID"/>
                        <w2:column dataType="text" id="dept_name" name="부서명"/>
                    </w2:columnInfo>
                </w2:dataList>
                
                <!-- 배정규칙 목록을 저장할 dataList 추가 -->
                <w2:dataList baseNode="list" id="dlt_assignRuleList" saveRemovedData="true">
                    <w2:columnInfo>
                        <w2:column dataType="text" id="rule_id" name="규칙ID"/>
                        <w2:column dataType="text" id="keyword" name="키워드"/>
                        <w2:column dataType="text" id="dept" name="부서명"/>
                    </w2:columnInfo>
                </w2:dataList>
            </w2:dataCollection>
            
            <!-- submission 수정 -->
            <xf:submission id="sbm_selectDepartmentList" 
                ref='data:json,{"id":"dma_modalData","key":"insDeptVo"}' 
                target='data:json,{"id":"dlt_departmentList","key":"elData.insDeptVoList"}' 
                action="/InsWebApp/insdept0001List.pwkjson" 
                method="post" 
                mediatype="application/json" 
                encoding="UTF-8" 
                instance="" 
                replace="" 
                errorHandler="" 
                customHandler="" 
                mode="asynchronous" 
                processMsg="" 
                ev:submit="" 
                ev:submitdone="scwin.sbm_selectDepartmentList_submitdone" 
                ev:submiterror="" 
                abortTrigger="">
            </xf:submission>
            
            <!-- 자동배정 규칙 저장 - 올바른 형식으로 수정 -->
            <xf:submission id="sbm_saveAutoAssignRule" 
                ref='data:json,{"id":"dmp_assignRuleVo","key":"assignRuleVo"}' 
                target='data:json,dmp_assignRuleVo' 
                action="/InsWebApp/assignrule0001Ins.pwkjson" 
                method="post" 
                mediatype="application/json" 
                encoding="UTF-8" 
                instance="" 
                replace="" 
                errorHandler="" 
                customHandler="" 
                mode="asynchronous" 
                processMsg="" 
                ev:submit="" 
                ev:submitdone="scwin.sbm_saveAutoAssignRule_submitdone" 
                ev:submiterror="" 
                abortTrigger="">
            </xf:submission>
            
            <!-- 자동배정 규칙 삭제 -->
            <xf:submission id="sbm_deleteAutoAssignRule" 
                ref='data:json,{"id":"dmp_assignRuleVo","key":"assignRuleVo"}' 
                target='data:json,dmp_assignRuleVo' 
                action="/InsWebApp/assignrule0001Del.pwkjson" 
                method="post" 
                mediatype="application/json" 
                encoding="UTF-8" 
                instance="" 
                replace="" 
                errorHandler="" 
                customHandler="" 
                mode="asynchronous" 
                processMsg="" 
                ev:submit="" 
                ev:submitdone="scwin.sbm_deleteAutoAssignRule_submitdone" 
                ev:submiterror="" 
                abortTrigger="">
            </xf:submission>
            
            <!-- 자동배정 규칙 목록 조회 -->
            <xf:submission id="sbm_selectAssignRuleList" 
                ref='data:json,{"id":"dmp_assignRuleVo","key":"assignRuleVo"}' 
                target='data:json,{"id":"dlt_assignRuleList","key":"elData.assignRuleVoList"}' 
                action="/InsWebApp/assignrule0001List.pwkjson" 
                method="post" 
                mediatype="application/json" 
                encoding="UTF-8" 
                instance="" 
                replace="" 
                errorHandler="" 
                customHandler="" 
                mode="asynchronous" 
                processMsg="" 
                ev:submit="" 
                ev:submitdone="scwin.sbm_selectAssignRuleList_submitdone" 
                ev:submiterror="" 
                abortTrigger="">
            </xf:submission>
            
            <!-- 배치 자동 배정 실행 -->
            <xf:submission id="sbm_runAutoAssignmentBatch" 
             ref='data:json,{}' 
                target='data:json,dmp_assignRuleVo' 
                action="/InsWebApp/assignrule0009RunBatch.pwkjson" 
                method="post" 
                mediatype="application/json" 
                encoding="UTF-8" 
                instance="" 
                replace="" 
                errorHandler="" 
                customHandler="" 
                mode="asynchronous" 
                processMsg="" 
                ev:submit="" 
                ev:submitdone="scwin.sbm_runAutoAssignmentBatch_submitdone" 
                ev:submiterror="" 
                abortTrigger="">
            </xf:submission>
            
            <!-- 청구 유형별 배정 미리보기 -->
            <xf:submission id="sbm_previewAssignment" 
                ref='data:json,{"id":"dmp_assignRuleVo","key":"assignRuleVo"}' 
                target='data:json,dmp_assignRuleVo' 
                action="/InsWebApp/assignrule0010PreviewAssignment.pwkjson" 
                method="post" 
                mediatype="application/json" 
                encoding="UTF-8" 
                instance="" 
                replace="" 
                errorHandler="" 
                customHandler="" 
                mode="asynchronous" 
                processMsg="" 
                ev:submit="" 
                ev:submitdone="scwin.sbm_previewAssignment_submitdone" 
                ev:submiterror="" 
                abortTrigger="">
            </xf:submission>
            
            <w2:workflowCollection/>
        </xf:model>
        <w2:layoutInfo/>
        <w2:publicInfo method=""/>
        <style type="text/css"><![CDATA[
            /* 기존 스타일 유지 */
            .editing {
                background-color: #fffbf0 !important;
                border: 1px solid #ff9800 !important;
            }
            
            #rule_container .rule_item:hover {
                border-color: #4285f4;
                box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            }
            
            .btn_cm {
                background-color: #4285f4;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                transition: background-color 0.3s;
            }
            
            .btn_cm:hover {
                background-color: #3367d6;
            }
            
            .btn_delete {
                background-color: #dc3545;
            }
            
            .btn_delete:hover {
                background-color: #c82333;
            }
            
            select {
                width: 250px;
                padding: 5px;
                border: 1px solid #ddd;
                border-radius: 3px;
                background-color: white;
                cursor: pointer;
            }
            
            select:focus {
                outline: none;
                border-color: #4285f4;
            }
            
            /* 규칙 항목 내 텍스트 표시 스타일 추가 */
            .rule_keyword {
                font-size: 14px;
                color: #333;
                font-weight: 500;
                display: inline-block;
                margin-left: 5px;
            }
            
            .rule_dept {
                font-size: 13px;
                color: #666;
                display: inline-block;
                margin-left: 5px;
            }
        ]]></style>
        <script lazy="false" type="text/javascript"><![CDATA[
/**
 * 자동배정 규칙 관리 시스템
 * 청구 건에 대한 자동 배정 규칙을 설정하고 관리하는 모듈
 * 
 * 주요 기능:
 * - 부서별 자동배정 규칙 설정
 * - 키워드 기반 배정 시스템
 * - 일괄 자동배정 처리
 * - 실시간 웹소켓 알림
 */

// =============================================================================
// 상수 및 설정값 정의
// =============================================================================
const ASSIGNMENT_CONFIG = {
    PAGE_SIZE: 10,                    // 기본 페이지 크기
    MODAL_Z_INDEX: 9999,             // 모달 Z-인덱스
    BACKDROP_Z_INDEX: 9998,          // 배경 Z-인덱스
    FOCUS_DELAY: 100                 // 포커스 지연시간 (ms)
};

const UI_MESSAGES = {
    SELECT_DEPARTMENT: "-- 부서를 선택하세요 --",
    RULE_ADD_TITLE: "규칙 추가",
    RULE_EDIT_TITLE: "규칙 수정",
    CONFIRM_DELETE: "이 규칙을 삭제하시겠습니까?",
    CONFIRM_BATCH: "미배정 청구들을 일괄로 자동 배정하시겠습니까?",
    VALIDATION_ERROR: "키워드와 부서를 모두 선택해주세요.",
    DELETE_SUCCESS: "삭제가 완료되었습니다.",
    BATCH_COMPLETE: "배치 배정 완료",
    BATCH_FAILED: "배치 배정 실패",
    PREVIEW_TITLE: "배정 미리보기 결과"
};

// =============================================================================
// 페이지 초기화 및 기본 설정
// =============================================================================

/**
 * 페이지 로드 완료 시 실행되는 메인 초기화 함수
 * 부서 목록 로드 및 웹소켓 연결을 수행
 */
scwin.onpageload = async function () {
    try {
        await initializeAssignmentSystem();
    } catch (error) {
        console.error("자동배정 시스템 초기화 실패:", error);
        alert("시스템 초기화 중 오류가 발생했습니다.");
    }
};

/**
 * 자동배정 시스템 전체 초기화
 * 부서 목록 초기화 → 부서 데이터 로드 → 웹소켓 연결 순으로 진행
 */
async function initializeAssignmentSystem() {
    // 부서 목록 배열 초기화
    scwin.departmentList = [
        { value: "", text: UI_MESSAGES.SELECT_DEPARTMENT }
    ];
    
    // 순차적으로 초기화 진행
    await scwin.loadDepartmentList();
    scwin.initWebSocket();
    
    console.log("자동배정 시스템 초기화 완료");
}

/**
 * 웹소켓 서비스 초기화
 * WebSocketService가 존재하는 경우에만 연결 시도
 */
scwin.initWebSocket = function() {
    try {
        if (typeof WebSocketService !== 'undefined') {
            WebSocketService.init(); // 세션 정보로 자동 연결
            console.log("웹소켓 서비스 초기화 완료");
        } else {
            console.log("WebSocketService를 찾을 수 없습니다.");
        }
    } catch (error) {
        console.error("웹소켓 초기화 실패:", error.message);
    }
};

// =============================================================================
// 부서 정보 관리
// =============================================================================

/**
 * INSDEPT 테이블에서 부서 정보를 조회하는 함수
 * 페이징 설정 후 서버에 부서 목록 요청
 */
scwin.loadDepartmentList = async function () {
    // 페이징 정보 설정 (충분히 큰 값으로 모든 부서 조회)
    setDepartmentPaging();
    
    // 부서 목록 조회 submission 실행
    await $c.sbm.execute($p, sbm_selectDepartmentList);
};

/**
 * 부서 조회를 위한 페이징 정보 설정
 */
function setDepartmentPaging() {
    dma_modalData.set("pageIndex", "1");
    dma_modalData.set("pageSize", ASSIGNMENT_CONFIG.PAGE_SIZE.toString());
}

/**
 * 부서 정보 조회 완료 콜백 함수
 * 조회된 부서 정보를 departmentList 배열에 저장하고 기존 규칙 로드
 */
scwin.sbm_selectDepartmentList_submitdone = async function (e) {
    const { elData, elHeader } = e.responseJSON;

    // 응답 유효성 검증
    if (!isValidResponse(elHeader)) {
        console.error("부서 목록 조회 실패:", elHeader);
        return false;
    }

    // 부서 목록 데이터 구성
    buildDepartmentList();
    
    // 부서 로드 완료 후 기존 규칙들 로드
    await scwin.loadExistingRules();
};

/**
 * 조회된 부서 데이터로 부서 목록 배열 구성
 */
function buildDepartmentList() {
    // 부서 목록 초기화
    scwin.departmentList = [{ 
        value: "", 
        text: UI_MESSAGES.SELECT_DEPARTMENT 
    }];

    const deptCount = dlt_departmentList.getRowCount();

    // 조회된 부서 정보를 배열에 추가
    for (let i = 0; i < deptCount; i++) {
        const deptData = extractDepartmentData(i);
        
        if (isValidDepartmentData(deptData)) {
            scwin.departmentList.push({
                value: deptData.id,
                text: deptData.name
            });
        }
    }
    
    console.log(`부서 목록 로드 완료: ${scwin.departmentList.length - 1}개 부서`);
}

/**
 * 부서 데이터 추출
 */
function extractDepartmentData(index) {
    return {
        id: dlt_departmentList.getCellData(index, "dept_id"),
        name: dlt_departmentList.getCellData(index, "dept_name")
    };
}

/**
 * 부서 데이터 유효성 검증
 */
function isValidDepartmentData(deptData) {
    return deptData.id && deptData.name;
}

// =============================================================================
// 배정 규칙 관리
// =============================================================================

/**
 * 기존 배정 규칙 목록 조회
 * 화면 초기화 후 서버에서 기존 규칙들을 가져와 표시
 */
scwin.loadExistingRules = async function () {
    // 기존 데이터 초기화
    dlt_assignRuleList.removeAll();
    clearRuleSearchParams();
    
    // 배정 규칙 목록 조회
    await $c.sbm.execute($p, sbm_selectAssignRuleList);
};

/**
 * 규칙 조회 조건 초기화
 */
function clearRuleSearchParams() {
    dmp_assignRuleVo.set("rule_id", "");
    dmp_assignRuleVo.set("keyword", "");
    dmp_assignRuleVo.set("dept", "");
}

/**
 * 배정 규칙 목록 조회 완료 콜백
 * 조회된 규칙들을 Generator 컴포넌트에 동적으로 추가
 */
scwin.sbm_selectAssignRuleList_submitdone = async function (e) {
    const { elData, elHeader } = e.responseJSON;

    if (!elHeader || !elHeader.resSuc) {
        console.error("규칙 목록 조회 실패:", elHeader);
        return;
    }

    // 기존 Generator 내용 제거
    rule_gen.removeAll();

    // 조회된 규칙들을 Generator에 추가
    await populateRuleGenerator();
};

/**
 * 규칙 Generator에 기존 규칙들 추가
 */
async function populateRuleGenerator() {
    const ruleCount = dlt_assignRuleList.getRowCount();
    
    console.log(`로드할 규칙 수: ${ruleCount}개`);

    // 모든 규칙을 순차적으로 Generator에 추가
    for (let i = 0; i < ruleCount; i++) {
        const ruleData = extractRuleData(i);
        
        if (isValidRuleData(ruleData)) {
            await scwin.addRuleToGenerator(
                ruleData.keyword, 
                ruleData.dept, 
                ruleData.ruleId
            );
        }
    }
}

/**
 * 규칙 데이터 추출
 */
function extractRuleData(index) {
    return {
        keyword: dlt_assignRuleList.getCellData(index, "keyword"),
        dept: dlt_assignRuleList.getCellData(index, "dept"),
        ruleId: dlt_assignRuleList.getCellData(index, "rule_id")
    };
}

/**
 * 규칙 데이터 유효성 검증
 */
function isValidRuleData(ruleData) {
    return ruleData.keyword && ruleData.dept;
}

/**
 * Generator에 새로운 규칙 항목 추가
 * 동적으로 UI 요소를 생성하고 데이터를 설정
 * 
 * @param {string} keyword - 배정 키워드
 * @param {string} deptName - 부서명
 * @param {string} ruleId - 규칙 ID (신규인 경우 빈 문자열)
 */
scwin.addRuleToGenerator = async function (keyword, deptName, ruleId) {
    try {
        // Generator에 새 항목 추가
        await rule_gen.insertChild();
        
        const targetIndex = rule_gen.getChildrenCount() - 1;
        const components = getRuleComponents(targetIndex);
        
        if (areComponentsValid(components)) {
            await configureRuleComponents(components, keyword, deptName, ruleId, targetIndex);
        } else {
            console.error("필수 컴포넌트를 찾을 수 없습니다. 인덱스:", targetIndex);
        }
    } catch (error) {
        console.error("규칙 추가 중 오류:", error);
    }
};

/**
 * 규칙 항목의 컴포넌트들 가져오기
 */
function getRuleComponents(index) {
    return {
        keywordDisplay: rule_gen.getChild(index, "item_keyword_display"),
        deptDisplay: rule_gen.getChild(index, "item_dept_display"),
        editBtn: rule_gen.getChild(index, "item_edit"),
        deleteBtn: rule_gen.getChild(index, "item_delete"),
        ruleItem: rule_gen.getChild(index, "rule_item")
    };
}

/**
 * 컴포넌트 유효성 검증
 */
function areComponentsValid(components) {
    return components.keywordDisplay && 
           components.deptDisplay && 
           components.editBtn && 
           components.deleteBtn;
}

/**
 * 규칙 컴포넌트에 데이터 설정
 */
async function configureRuleComponents(components, keyword, deptName, ruleId, index) {
    // 화면 표시 요소에 값 설정
    await components.keywordDisplay.setValue(keyword);
    await components.deptDisplay.setValue(deptName);

    // 버튼에 사용자 데이터 저장
    const userData = {
        ruleId: ruleId || "",
        keyword: keyword,
        deptName: deptName,
        itemIndex: index
    };

    setComponentUserData(components.editBtn, userData);
    setComponentUserData(components.deleteBtn, userData);

    // rule_item에도 정보 저장
    if (components.ruleItem) {
        setComponentUserData(components.ruleItem, userData);
    }
}

/**
 * 컴포넌트에 사용자 데이터 설정
 */
function setComponentUserData(component, userData) {
    Object.keys(userData).forEach(key => {
        component.setUserData(key, userData[key]);
    });
}

// =============================================================================
// 부서 관련 유틸리티 함수
// =============================================================================

/**
 * 부서 ID로 부서명 조회
 * @param {string} deptId - 부서 ID
 * @returns {string} 부서명 (찾지 못한 경우 ID 반환)
 */
scwin.getDepartmentName = function (deptId) {
    const dept = scwin.departmentList.find(d => d.value === deptId);
    return dept ? dept.text : deptId;
};

/**
 * 부서명으로 부서 ID 조회
 * @param {string} deptName - 부서명
 * @returns {string} 부서 ID (찾지 못한 경우 빈 문자열 반환)
 */
scwin.getDepartmentId = function (deptName) {
    const dept = scwin.departmentList.find(d => d.text === deptName);
    return dept ? dept.value : "";
};

// =============================================================================
// 이벤트 핸들러
// =============================================================================

/**
 * 규칙 추가 버튼 클릭 이벤트
 * 새로운 배정 규칙 추가를 위한 모달 표시
 */
scwin.add_rule_onclick = async function (e) {
    scwin.showModal("add");
};

/**
 * 규칙 수정 버튼 클릭 이벤트
 * 기존 규칙 수정을 위한 모달 표시
 */
scwin.item_edit_onclick = async function (e) {
    try {
        const userData = getButtonUserData(this);
        scwin.showModal("edit", userData.keyword, userData.deptName, userData.ruleId);
    } catch (error) {
        console.error("수정 버튼 처리 중 오류:", error);
    }
};

/**
 * 버튼에서 사용자 데이터 추출
 */
function getButtonUserData(button) {
    return {
        ruleId: button.getUserData("ruleId"),
        keyword: button.getUserData("keyword"),
        deptName: button.getUserData("deptName")
    };
}

/**
 * 규칙 삭제 버튼 클릭 이벤트
 * 삭제 확인 후 규칙 제거 처리
 */
scwin.item_delete_onclick = async function (e) {
    const confirmed = await showDeleteConfirmation();
    
    if (confirmed) {
        await handleRuleDeletion(this);
    }
};

// =============================================================================
// 모달 관리 시스템
// =============================================================================

/**
 * 통합 모달 표시 함수
 * 추가/수정 모드에 따라 적절한 모달 생성
 * 
 * @param {string} mode - "add" 또는 "edit"
 * @param {string} keyword - 키워드 (수정 모드시)
 * @param {string} deptName - 부서명 (수정 모드시)
 * @param {string} ruleId - 규칙 ID (수정 모드시)
 */
scwin.showModal = function (mode, keyword = "", deptName = "", ruleId = "") {
    // 기존 모달 제거
    removeExistingModal();
    
    // 모달 데이터 준비
    const modalData = prepareModalData(mode, keyword, deptName);
    
    // 모달 생성 및 표시
    const modalContainer = createModalContainer(modalData);
    document.body.appendChild(modalContainer);
    
    // 이벤트 핸들러 연결
    attachModalEventHandlers(mode, ruleId);
    
    // 키워드 입력란에 포커스
    focusKeywordInput();
};

/**
 * 기존 모달 제거
 */
function removeExistingModal() {
    const existingModal = document.getElementById('modalContainer');
    if (existingModal) {
        existingModal.remove();
    }
}

/**
 * 모달 데이터 준비
 */
function prepareModalData(mode, keyword, deptName) {
    const isAddMode = mode === "add";
    
    return {
        title: isAddMode ? UI_MESSAGES.RULE_ADD_TITLE : UI_MESSAGES.RULE_EDIT_TITLE,
        keyword: isAddMode ? "" : keyword,
        selectedDeptId: isAddMode ? "" : scwin.getDepartmentId(deptName),
        departmentOptions: generateDepartmentOptions(
            isAddMode ? "" : scwin.getDepartmentId(deptName)
        )
    };
}

/**
 * 부서 선택 옵션 HTML 생성
 */
function generateDepartmentOptions(selectedDeptId) {
    return scwin.departmentList.map(dept => {
        const selected = dept.value === selectedDeptId ? ' selected' : '';
        return `<option value="${dept.value}"${selected}>${dept.text}</option>`;
    }).join('');
}

/**
 * 모달 컨테이너 생성
 */
function createModalContainer(modalData) {
    const container = document.createElement('div');
    container.id = 'modalContainer';
    container.innerHTML = getModalHTML(modalData);
    return container;
}

/**
 * 모달 HTML 템플릿 생성
 */
function getModalHTML(data) {
    return `
        <div id="modalBackdrop" style="position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:${ASSIGNMENT_CONFIG.BACKDROP_Z_INDEX};"></div>
        <div id="customModal" style="position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:white; border:1px solid #ccc; padding:20px; z-index:${ASSIGNMENT_CONFIG.MODAL_Z_INDEX}; box-shadow:0 0 10px rgba(0,0,0,0.5); border-radius:5px; width:400px;">
            <h3 style="margin-top:0;">${data.title}</h3>
            <div style="margin-bottom:15px;">
                <label style="display:inline-block; width:80px; font-weight:bold;">키워드:</label>
                <input type="text" id="modalKeyword" value="${data.keyword}" style="width:250px; padding:5px;" placeholder="배정 키워드를 입력하세요" />
            </div>
            <div style="margin-bottom:15px;">
                <label style="display:inline-block; width:80px; font-weight:bold;">부서:</label>
                <select id="modalDepartment" style="width:262px; padding:5px;">
                    ${data.departmentOptions}
                </select>
            </div>
            <div style="text-align:center; margin-top:20px;">
                <button id="modalConfirmBtn" style="padding:8px 20px; margin-right:10px; cursor:pointer; background-color:#4285f4; color:white; border:none; border-radius:4px;">확인</button>
                <button id="modalCancelBtn" style="padding:8px 20px; cursor:pointer; background-color:#6c757d; color:white; border:none; border-radius:4px;">취소</button>
            </div>
        </div>
    `;
}

/**
 * 모달 이벤트 핸들러 연결
 */
function attachModalEventHandlers(mode, ruleId) {
    const confirmHandler = () => handleModalConfirm(mode, ruleId);
    const cancelHandler = closeModal;
    
    // 버튼 이벤트
    document.getElementById('modalConfirmBtn').addEventListener('click', confirmHandler);
    document.getElementById('modalCancelBtn').addEventListener('click', cancelHandler);
    document.getElementById('modalBackdrop').addEventListener('click', cancelHandler);
    
    // 키보드 이벤트
    attachKeyboardHandlers(confirmHandler);
}

/**
 * 키보드 이벤트 핸들러 연결
 */
function attachKeyboardHandlers(confirmHandler) {
    // 키워드 입력란에서 Enter 키 → 부서 선택으로 포커스 이동
    document.getElementById('modalKeyword').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            document.getElementById('modalDepartment').focus();
        }
    });
    
    // 부서 선택에서 Enter 키 → 확인 버튼 클릭
    document.getElementById('modalDepartment').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            confirmHandler();
        }
    });
}

/**
 * 키워드 입력란에 포커스 설정
 */
function focusKeywordInput() {
    setTimeout(() => {
        const keywordInput = document.getElementById('modalKeyword');
        if (keywordInput) {
            keywordInput.focus();
            keywordInput.select(); // 기존 텍스트 선택
        }
    }, ASSIGNMENT_CONFIG.FOCUS_DELAY);
}

/**
 * 모달 확인 버튼 처리
 */
async function handleModalConfirm(mode, ruleId) {
    const formData = getModalFormData();
    
    // 입력값 유효성 검증
    if (!validateModalData(formData)) {
        alert(UI_MESSAGES.VALIDATION_ERROR);
        return;
    }
    
    // 모달 닫기
    closeModal();
    
    // 모드에 따른 처리
    if (mode === "add") {
        await handleRuleAddition(formData);
    } else {
        await handleRuleEdit(formData, ruleId);
    }
}

/**
 * 모달 폼 데이터 추출
 */
function getModalFormData() {
    const keyword = document.getElementById('modalKeyword').value.trim();
    const deptId = document.getElementById('modalDepartment').value;
    
    return {
        keyword: keyword,
        deptId: deptId,
        deptName: scwin.getDepartmentName(deptId)
    };
}

/**
 * 모달 데이터 유효성 검증
 */
function validateModalData(data) {
    return data.keyword && data.deptId;
}

/**
 * 모달 닫기
 */
function closeModal() {
    const modal = document.getElementById('modalContainer');
    if (modal) {
        modal.remove();
    }
}

// =============================================================================
// 규칙 추가/수정/삭제 처리
// =============================================================================

/**
 * 새로운 규칙 추가 처리
 */
async function handleRuleAddition(formData) {
    // 화면에 즉시 추가
    await scwin.addRuleToGenerator(formData.keyword, formData.deptName, "");
    
    // 서버에 저장
    scwin.saveAutoAssignRule(formData.keyword, formData.deptName);
}

/**
 * 기존 규칙 수정 처리
 */
async function handleRuleEdit(formData, ruleId) {
    // 화면 업데이트
    await updateRuleInGenerator(formData, ruleId);
    
    // 서버에 저장
    scwin.saveAutoAssignRule(formData.keyword, formData.deptName, ruleId);
}

/**
 * Generator에서 규칙 업데이트
 */
async function updateRuleInGenerator(formData, ruleId) {
    const childCount = rule_gen.getChildrenCount();
    
    for (let i = 0; i < childCount; i++) {
        const editBtn = rule_gen.getChild(i, "item_edit");
        
        if (editBtn && editBtn.getUserData("ruleId") === ruleId) {
            await updateRuleComponents(i, formData);
            break;
        }
    }
}

/**
 * 규칙 컴포넌트 업데이트
 */
async function updateRuleComponents(index, formData) {
    const components = getRuleComponents(index);
    
    if (components.keywordDisplay && components.deptDisplay) {
        // 화면 표시 업데이트
        await components.keywordDisplay.setValue(formData.keyword);
        await components.deptDisplay.setValue(formData.deptName);
        
        // 사용자 데이터 업데이트
        const userData = { 
            keyword: formData.keyword, 
            deptName: formData.deptName 
        };
        
        updateComponentUserData(components.editBtn, userData);
        updateComponentUserData(components.deleteBtn, userData);
    }
}

/**
 * 컴포넌트 사용자 데이터 업데이트
 */
function updateComponentUserData(component, userData) {
    Object.keys(userData).forEach(key => {
        component.setUserData(key, userData[key]);
    });
}

/**
 * 자동배정 규칙 서버 저장
 * @param {string} keyword - 키워드
 * @param {string} deptName - 부서명
 * @param {string} ruleId - 규칙 ID (수정시)
 */
scwin.saveAutoAssignRule = async function (keyword, deptName, ruleId = "") {
    // 데이터 설정
    dmp_assignRuleVo.set("keyword", keyword);
    dmp_assignRuleVo.set("dept", deptName);
    dmp_assignRuleVo.set("rule_id", ruleId);
    
    // 서버 전송
    await $c.sbm.execute($p, sbm_saveAutoAssignRule);
};

/**
 * 규칙 저장 완료 콜백
 * 신규 규칙인 경우 서버에서 생성된 rule_id를 화면에 반영
 */
scwin.sbm_saveAutoAssignRule_submitdone = function (e) {
    const { elHeader, elData } = e.responseJSON;

    if (!isValidResponse(elHeader)) {
        console.error("규칙 저장 실패:", elHeader);
        return false;
    }

    // 신규 규칙인 경우 생성된 rule_id 설정
    handleNewRuleId(elData);
};

/**
 * 신규 규칙 ID 처리
 */
function handleNewRuleId(elData) {
    if (elData?.assignRuleVo?.rule_id) {
        const newRuleId = elData.assignRuleVo.rule_id;
        updateNewRuleWithId(newRuleId);
        console.log("신규 규칙 ID 설정 완료:", newRuleId);
    }
}

/**
 * 새로 생성된 규칙에 ID 설정
 */
function updateNewRuleWithId(newRuleId) {
    const childCount = rule_gen.getChildrenCount();
    
    // rule_id가 없는 항목(신규 생성 항목) 찾아서 ID 설정
    for (let i = 0; i < childCount; i++) {
        const editBtn = rule_gen.getChild(i, "item_edit");
        const deleteBtn = rule_gen.getChild(i, "item_delete");
        
        if (editBtn && !editBtn.getUserData("ruleId")) {
            editBtn.setUserData("ruleId", newRuleId);
            deleteBtn.setUserData("ruleId", newRuleId);
            break;
        }
    }
}

/**
 * 삭제 확인 모달 표시
 */
function showDeleteConfirmation() {
    return new Promise((resolve) => {
        const modal = createDeleteModal();
        document.body.appendChild(modal);
        
        // 확인 버튼
        document.getElementById('deleteConfirm').addEventListener('click', () => {
            modal.remove();
            resolve(true);
        });
        
        // 취소 버튼 및 배경 클릭
        document.getElementById('deleteCancel').addEventListener('click', () => {
            modal.remove();
            resolve(false);
        });
        
        document.getElementById('deleteBackdrop').addEventListener('click', () => {
            modal.remove();
            resolve(false);
        });
    });
}

/**
 * 삭제 확인 모달 생성
 */
function createDeleteModal() {
    const modalDiv = document.createElement('div');
    modalDiv.innerHTML = `
        <div id="deleteBackdrop" style="position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:${ASSIGNMENT_CONFIG.BACKDROP_Z_INDEX};"></div>
        <div id="deleteModal" style="position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:white; border-radius:8px; padding:20px; z-index:${ASSIGNMENT_CONFIG.MODAL_Z_INDEX}; box-shadow:0 0 20px rgba(0,0,0,0.3); width:300px;">
            <h3 style="margin:0 0 15px 0; font-size:16px;">규칙 삭제</h3>
            <p style="margin:0 0 20px 0; color:#666; font-size:14px;">${UI_MESSAGES.CONFIRM_DELETE}</p>
            <div style="text-align:right;">
                <button id="deleteCancel" style="padding:6px 15px; margin-right:10px; border:1px solid #ddd; background:white; border-radius:4px; cursor:pointer;">취소</button>
                <button id="deleteConfirm" style="padding:6px 15px; background:#dc3545; color:white; border:none; border-radius:4px; cursor:pointer;">삭제</button>
            </div>
        </div>
    `;
    return modalDiv;
}

/**
 * 규칙 삭제 처리
 */
async function handleRuleDeletion(button) {
    try {
        const userData = getButtonUserData(button);
        
        if (userData.ruleId) {
            // 서버에서 삭제
            await scwin.deleteAutoAssignRule(userData.ruleId);
            // 화면에서 제거
            removeRuleFromGenerator(userData.ruleId);
        } else {
            // 저장되지 않은 신규 항목 삭제
            const index = button.getGeneratedIndex();
            if (index !== undefined && index !== -1) {
                rule_gen.removeChild(index);
                console.log("신규 항목 삭제 완료 - 인덱스:", index);
            }
        }
    } catch (error) {
        console.error("삭제 처리 중 오류:", error);
    }
}

/**
 * 서버에서 배정 규칙 삭제
 */
scwin.deleteAutoAssignRule = async function (ruleId) {
    dmp_assignRuleVo.set("rule_id", ruleId);
    dmp_assignRuleVo.set("keyword", "");
    dmp_assignRuleVo.set("dept", "");
    
    await $c.sbm.execute($p, sbm_deleteAutoAssignRule);
};

/**
 * Generator에서 규칙 제거
 */
function removeRuleFromGenerator(ruleId) {
    const childCount = rule_gen.getChildrenCount();
    
    for (let i = 0; i < childCount; i++) {
        const editBtn = rule_gen.getChild(i, "item_edit");
        
        if (editBtn && editBtn.getUserData("ruleId") === ruleId) {
            rule_gen.removeChild(i);
            console.log("규칙 제거 완료 - 인덱스:", i, "ID:", ruleId);
            break;
        }
    }
}

/**
 * 규칙 삭제 완료 콜백
 */
scwin.sbm_deleteAutoAssignRule_submitdone = function (e) {
    const { elHeader } = e.responseJSON;

    if (!isValidResponse(elHeader)) {
        $c.win.alert(`에러코드: ${elHeader.resCode}\n에러메시지: ${elHeader.resMsg}`);
        return false;
    }
    
    $c.win.alert(UI_MESSAGES.DELETE_SUCCESS);
};

// =============================================================================
// 배치 자동배정 및 테스트 기능
// =============================================================================

/**
 * 일괄 자동배정 실행 버튼 클릭 이벤트
 * 미배정된 모든 청구 건에 대해 배정 규칙을 적용
 */
scwin.testBatchAssignment_onclick = async function () {
    if (confirm(UI_MESSAGES.CONFIRM_BATCH)) {
        try {
            await $c.sbm.execute($p, sbm_runAutoAssignmentBatch);
        } catch (error) {
            console.error("배치 배정 실행 중 오류:", error);
            alert("배치 배정 실행 중 오류가 발생했습니다.");
        }
    }
};

/**
 * 배치 자동배정 완료 콜백
 * 서버 응답을 파싱하여 결과 메시지 표시
 */
scwin.sbm_runAutoAssignmentBatch_submitdone = function (e) {
    console.log("배치 배정 응답:", e.responseJSON);
    
    const result = parseBatchResponse(e.responseJSON);
    
    if (result.success) {
        $c.win.alert(`${UI_MESSAGES.BATCH_COMPLETE}\n${result.message}`);
        // 웹소켓 알림 전송
        scwin.sendBatchCompleteNotification(e.responseJSON);
    } else {
        $c.win.alert(`${UI_MESSAGES.BATCH_FAILED}\n${result.message}`);
    }
};

/**
 * 배치 배정 응답 파싱
 * 다양한 응답 형식을 통합 처리
 */
function parseBatchResponse(response) {
    // 직접 success/message 형식
    if (typeof response.success !== 'undefined') {
        return {
            success: response.success,
            message: response.message || "처리 완료"
        };
    }
    
    // WebSquare 표준 형식
    const { elData, elHeader } = response;
    
    if (elHeader?.resSuc === true && elData?.success) {
        return {
            success: true,
            message: elData.message || "배치 배정이 완료되었습니다."
        };
    }
    
    // 실패 케이스
    return {
        success: false,
        message: elHeader?.resMsg || elData?.message || "알 수 없는 오류가 발생했습니다."
    };
}

/**
 * 일괄 배정 완료 웹소켓 알림 전송
 * 배정 완료를 다른 사용자들에게 실시간 알림
 */
scwin.sendBatchCompleteNotification = function(batchResult) {
    $p.ajax({
        url: "/websocket0002BatchAssignWithNotification",
        success: (data) => {
            console.log("일괄 배정 알림 전송 완료:", data);
        },
        error: (error) => {
            console.error("일괄 배정 알림 전송 실패:", error);
        }
    });
};

/**
 * 청구 유형별 배정 미리보기 테스트
 * 특정 청구 유형에 대한 배정 결과를 미리 확인
 */
scwin.testPreviewAssignment_onclick = async function () {
    const claimType = prompt("청구 유형을 입력하세요 (예: 비용, 사고, 방문처치)");
    
    if (claimType?.trim()) {
        try {
            setPreviewParams(claimType.trim());
            await $c.sbm.execute($p, sbm_previewAssignment);
        } catch (error) {
            console.error("미리보기 실행 중 오류:", error);
            alert("미리보기 실행 중 오류가 발생했습니다.");
        }
    }
};

/**
 * 미리보기용 파라미터 설정
 */
function setPreviewParams(claimType) {
    dmp_assignRuleVo.set("keyword", claimType);
    dmp_assignRuleVo.set("dept", "");
    dmp_assignRuleVo.set("rule_id", "");
}

/**
 * 배정 미리보기 완료 콜백
 * 미리보기 결과를 사용자 친화적인 형태로 표시
 */
scwin.sbm_previewAssignment_submitdone = function (e) {
    const { elData, elHeader } = e.responseJSON;
    
    if (elHeader?.resSuc && elData?.success) {
        const message = buildPreviewMessage(elData);
        $c.win.alert(message);
    } else {
        const errorMsg = elData?.message || elHeader?.resMsg || "미리보기 처리 중 오류가 발생했습니다.";
        $c.win.alert(`미리보기 실패\n${errorMsg}`);
    }
};

/**
 * 미리보기 결과 메시지 구성
 */
function buildPreviewMessage(data) {
    let message = `${UI_MESSAGES.PREVIEW_TITLE}\n\n`;
    message += `청구 유형: ${data.claimType}\n`;
    message += `매칭 키워드: ${data.matchedKeyword}\n`;
    message += `배정 부서: ${data.deptName}\n`;
    message += `가능 직원 수: ${data.employeeCount}명\n\n`;
    
    if (data.primaryAssignee) {
        message += `우선 배정 대상: ${data.primaryAssignee.ename} (${data.primaryAssignee.empno})`;
    }
    
    return message;
}

// =============================================================================
// 유틸리티 함수
// =============================================================================

/**
 * 서버 응답 유효성 검증
 * @param {Object} elHeader - 응답 헤더
 * @returns {boolean} 유효성 여부
 */
function isValidResponse(elHeader) {
    return elHeader && 
           elHeader !== "" && 
           elHeader !== "undefined" && 
           elHeader.resSuc !== false;
}

]]></script>
    </head>
    <body ev:onpageload="scwin.onpageload">
        <xf:group class="sub_contents" id="" style="">
            <xf:group class="pgtbox" id="" style="">
                <w2:textbox class="pgt_tit" id="" label="자동배정 설정" style="" tagname=""/>
            </xf:group>
            
            <xf:group class="titbox" id="" style="">
                <w2:textbox class="" id="" label="현재 적용 중인 규칙" style="" tagname="h4"/>
            </xf:group>
            
            <xf:group id="rule_container" style="padding:20px;">
                <w2:generator id="rule_gen" style="">
                    <xf:group id="rule_item" style="width:100%; margin-bottom:15px; padding:20px; border:1px solid #e0e0e0; border-radius:8px; background-color:#ffffff; box-shadow: 0 2px 4px rgba(0,0,0,0.1); box-sizing:border-box;">
                        <xf:group style="display:flex; justify-content:space-between; align-items:flex-start; width:100%;">
                            <xf:group style="flex:1; min-width:0; padding-right:10px;">
                                <xf:group style="margin-bottom:10px;">
                                    <w2:textbox label="키워드 : " style="display:inline-block; font-size:13px; color:#666; margin-bottom:5px;"/>
                                    <w2:span id="item_keyword_display" label="" class="rule_keyword"/>
                                </xf:group>
                                <xf:group style="display:flex; align-items:flex-start;">
                                    <w2:span label="•" style="font-size:12px; color:#999; margin-right:5px; margin-top:2px;"/>
                                    <xf:group style="flex:1;">
                                        <w2:span id="item_dept_display" label="" class="rule_dept"/>
                                    </xf:group>
                                </xf:group>
                            </xf:group>
                            <xf:group style="display:flex; align-items:center; flex-shrink:0;">
                                <xf:trigger class="" ev:onclick="scwin.item_edit_onclick" id="item_edit" style="width:50px; height:30px; margin-right:5px; font-size:13px; border-radius: 10px;" type="button">
                                    <xf:label><![CDATA[수정]]></xf:label>
                                </xf:trigger>
                                <xf:trigger class="" ev:onclick="scwin.item_delete_onclick" id="item_delete" style="width:50px; height:30px; font-size:13px; border-radius: 10px;" type="button">
                                    <xf:label><![CDATA[삭제]]></xf:label>
                                </xf:trigger>
                            </xf:group>
                        </xf:group>
                    </xf:group>
                </w2:generator>
            </xf:group>
            
            <xf:group id="button_area" style="width:100%; text-align:right; margin-bottom: 100px;">
                <xf:trigger class="" ev:onclick="scwin.testBatchAssignment_onclick" id="test_batch" style="width:120px; height:35px; margin-right:10px;color:black;" type="button">
                    <xf:label><![CDATA[일괄 자동배정]]></xf:label>
                </xf:trigger>
                <xf:trigger class="btn_cm" ev:onclick="scwin.add_rule_onclick" id="add_rule" style="width:100px; height:35px;" type="button">
                    <xf:label><![CDATA[규칙 추가]]></xf:label>
                </xf:trigger>
            </xf:group>
        </xf:group>
    </body>
</html>